z = matrix(z, ncol = 501)
a = seq(-5, 10, 0.1)
b = seq(-10, 40, 0.1)
filled.contour(a, b, z)
sum(z)
max(z)
x = c(-0.86, -0.30, -0.05, 0.73)
n = c(5, 5, 5, 5)
y = c(0, 1, 3, 5)
a0 = seq(-5, 10, 0.1)
b0 = seq(-10, 40, 0.1)
post <- function (a,b,y,n,x) prod((invlogit(a+b*x))^y*(1-invlogit(a+b*x))^(n-y))
triangle.prior <- function(x) {
if (x >= 0 && x < 0.25)
8 * x
else if (x >= 0.25 && x <= 1)
8/3 - 8 * x/3
else 0
}
plot(seq(-1, 1, 0.01), triangle.prior(seq(-1, 1, 0.01)))
seq(-1, 1, 0.01)
triangle.prior(seq(-1, 1, 0.01))
y = sapply(x, triangle.prior)
x
y
x = seq(-1, 1, 0.01)
y = sapply(x, triangle.prior)
x
y
plot(x, y)
x = seq(-1, 2, 0.01)
y = sapply(x, triangle.prior)
plot(x, y)
posterior.function <- function(theta, n, y) {
(theta^y) * (1 - theta)^(n - y) * triangle.prior(theta)
}
m <- 100
grid.points <- seq(from = 0, to = 1, length.out = m)
grid.point
grid.points
unnormal.post.ord <- posterior.function(theta = grid.points, n = 500, y = 285)
unnormal.post.ord
k <- 1/m
normal.constant <- sum(k * unnormal.post.ord)
normal.constant
post.ord <- unnormal.post.ord/normal.constant
post.ord
plot(grid.points, post.ord)
plot(grid.points, post.ord, type = "l", col = "red")
?sample
posterior.triangle.1 <- sample(grid.points, size = 10000, replace = T, prob = post.ord)
hist(posterior.triangle.1)
hist(posterior.triangle.1, xlim = c(0, 1))
hist(posterior.triangle.1, xlim = c(0, 1))
posterior.triangle.1
poisson.posterior <- function(theta, y, x, prior.mean.a, prior.var.a, prior.mean.b, prior.var.b) {
a <- theta[1]
b <- theta[2]
lambda <- exp(a + b * x)
log.like <- sum(dpois(y, lambda = lambda, log = T))
log.prior.a <- dnorm(a, mean = prior.mean.a, sd = sqrt(prior.var.a), log = T)
log.prior.b <- dnorm(b, mean = prior.mean.b, sd = sqrt(prior.var.b), log = T)
log.post <- log.like + log.prior.a + log.prior.b
return(exp(log.post))
}
library(Zelig)
install.packages("Zelig")
library(Zelig)
data(sanction)
sanction
head(sanction)
plot(sanction$coop, sanction$num)
y.vec <- sanction$num
x.vec <- sanction$coop
y.vec
x.vec
mu.a <- mu.b <- 0
sigma2.a <- sigma2.b <- 20
mle <- glm(num ~ coop, data = sanction, family = poisson)$coef
mle
?glm
mle.se <- summary(glm(num ~ coop, data = sanction, family = poisson))$coef[, 2]
mle.se
grid.a <- seq(from = mle[1] - 5 * mle.se[1], to = mle[1] + 5 * mle.se[1], length.out = 200)
grid.b <- seq(from = mle[2] - 5 * mle.se[2], to = mle[2] + 5 * mle.se[2], length.out = 200)
grid.a
grid.b
grid.points <- expand.grid(grid.a, grid.b)
head(grid.points)
head(grid.a)
head(grid.b)
post.ord <- apply(grid.points, MARGIN = 1, FUN = poisson.posterior,
y = y.vec, x = x.vec, prior.mean.a = mu.a, prior.var.a = sigma2.a,
prior.mean.b = mu.b, prior.var.b = sigma2.b)
str(post.ord)
sample.indices <- sample(1:nrow(grid.points), size = 10000, replace = T, prob = post.ord)
sim.posterior <- grid.points[sample.indices, ]
dim(sim.posterior)
log_post <- function (a,b,y,n,x) sum (dbinom (y, n, invlogit(a+b*x), log.p=TRUE))
x = c(-0.86, -0.30, -0.05, 0.73)
n = c(5, 5, 5, 5)
y = c(0, 1, 3, 5)
a0 = seq(-5, 10, 0.1)
b0 = seq(-10, 40, 0.1)
a = a0[1]
b = b0[1]
dbinom (y, n, invlogit(a+b*x), log.p=TRUE)
invlogit(a+b*x)
?dbinom
sum(invlogit(a+b*x))
dbinom(y, n, invlogit(a+b*x))
dbinom(y[1], n[1], invlogit(a+b*x[1]))
dbinom(y[1], n[1], invlogit(a+b*x[1]), log.p = T)
log_post <- function (a,b,y,n,x) sum (dbinom (y, n, invlogit(a+b*x), log=TRUE))
log_post <- function (a,b,y,n,x) sum (dbinom (y, n, invlogit(a+b*x), log=TRUE))
dbinom (y, n, invlogit(a+b*x), log=TRUE)
grid.points <- expand.grid(a0, b0)
post.ord <- apply(grid.points, MARGIN = 1, FUN = log_post, y = y, n = n, x = x)
head(grid.points)
log_post <- function (a,b,y,n,x) exp^(sum (dbinom (y, n, invlogit(a+b*x), log=TRUE)))
post.ord <- apply(grid.points, MARGIN = 1, function(grid) log_post(grid[1], grid[2], y = y, n = n, x = x)
)
log_post <- function (a,b,y,n,x) exp^(sum (dbinom (y, n, invlogit(a+b*x), log=TRUE)))
post.ord <- apply(grid.points, 1, function(grid) log_post(grid[1], grid[2], y = y, n = n, x = x))
head(grid.points)
post.ord <- apply(grid.points, 1, function(t) log_post(a = t[1], b = t[2], y = y, n = n, x = x))
log_post <- function (a,b,y,n,x) {
loglik = sum (dbinom (y, n, invlogit(a+b*x), log=TRUE))
return(exp^(loglik))
}
log_post <- function (a,b,y,n,x) {
loglik = sum (dbinom (y, n, invlogit(a+b*x), log=TRUE))
return(exp(loglik))
}
post.ord <- apply(grid.points, 1, function(t) log_post(a = t[1], b = t[2], y = y, n = n, x = x))
post.ord
filled.contour(grid.points, post.ord)
filled.contour(grid.points, z = post.ord)
filled.contour(x = grid.points[, 1], y = grid.points[, 2], z = post.ord)
head(grid.points)
tail(grid.points)
filled.contour(x = grid.points$Var1, y = grid.points$Var2, z = post.ord)
?filled.contour
hist(post.ord)
sample.indices <- sample(1:nrow(grid.points), size = 10000, replace = T, prob = post.ord)
sim.posterior <- grid.points[sample.indices, ]
hist(sim.posterior[, 1])
hist(sim.posterior[, 2])
contour(x = grid.points$Var1, y = grid.points$Var2, z = post.ord)
grid.points$Var1
image.maker <- function(coords, value){
N <- length(unique(coords[,1]))
image.out <- matrix(NA, nrow = N, ncol = N)
coords[,1] <- as.numeric(factor(coords[,1]))
coords[,2] <- as.numeric(factor(coords[,2]))
for (i in 1:nrow(coords))
image.out[coords[i,1], coords[i,2]] <- value[i]
return(image.out)
}
image.maker(grid.points, post.ord)
for (t1 in a0) {
for (t2 in b0) {
log_post(a = t1, b = t2, y = y, n = n, x = x)
}
}
post.ord <- NULL
for (t1 in a0) {
for (t2 in b0) {
post0 = log_post(a = t1, b = t2, y = y, n = n, x = x)
post.ord = c(post.ord, post0)
}
}
post.ord <- NULL
for (t1 in a0) {
for (t2 in b0) {
post0 = log_post(a = t1, b = t2, y = y, n = n, x = x)
post.ord = rbind(post.ord, c(t1, t2, post0))
}
}
dim(post.ord)
sample.indices <- sample(1:nrow(post.ord), size = 10000, replace = T, prob = post.ord[, 3])
head(sample.indices)
sim.posterior <- post.ord[sample.indices, ]
hist(sim.posterior[, 1])
hist(sim.posterior[, 2])
contour(post.ord)
head(post.ord)
head(post.ord)
contour(x = post.ord[, 1], y = post.ord[, 2], z = post.ord[, 3])
stan_glm <- "
data {
int<lower=1> N;  // Sample number
int<lower=1> D;  // Predictors
row_vector[D] cov[N];  // Covariates
cov_matrix[N] Sigma;  // Kinship
vector[N] Ad;  // Ad status
}
transformed data {
matrix[N, N] L;
L <- cholesky_decompose(Sigma);
}
parameters {
real alpha;
vector[D] beta;
real<lower=machine_precision()> theta_e;
real<lower=machine_precision()> theta_u;
vector[N] u;
}
model {
alpha ~ cauchy(0, 1);
beta ~ cauchy(0, 1);
u ~ multi_normal_cholesky(rep_vector(0, N), theta_u * L);
{
vector[N] mu;
for (n in 1:N)
mu[n] <- alpha + cov[n] * beta + u[n];
Ad ~ normal(mu, theta_e);
}
}
"
stan_glm <- stan_model(model_code = stan_glm)
library(rstan)
stan_glm <- "
data {
int<lower=1> N;  // Sample number
int<lower=1> D;  // Predictors
row_vector[D] cov[N];  // Covariates
cov_matrix[N] Sigma;  // Kinship
vector[N] Ad;  // Ad status
}
transformed data {
matrix[N, N] L;
L <- cholesky_decompose(Sigma);
}
parameters {
real alpha;
vector[D] beta;
real<lower=machine_precision()> theta_e;
real<lower=machine_precision()> theta_u;
vector[N] u;
}
model {
alpha ~ cauchy(0, 1);
beta ~ cauchy(0, 1);
u ~ multi_normal_cholesky(rep_vector(0, N), theta_u * L);
{
vector[N] mu;
for (n in 1:N)
mu[n] <- alpha + cov[n] * beta + u[n];
Ad ~ normal(mu, theta_e);
}
}
"
stan_glm <- stan_model(model_code = stan_glm)
library(rstan)
stan_glm <- "
data {
int<lower=1> N;  // Sample number
int<lower=1> D;  // Predictors
row_vector[D] cov[N];  // Covariates
cov_matrix[N] Sigma;  // Kinship
vector[N] Ad;  // Ad status
}
transformed data {
matrix[N, N] L;
L <- cholesky_decompose(Sigma);
}
parameters {
real alpha;
vector[D] beta;
real<lower=machine_precision()> theta_e;
real<lower=machine_precision()> theta_u;
vector[N] u;
}
model {
alpha ~ cauchy(0, 1);
beta ~ cauchy(0, 1);
u ~ multi_normal_cholesky(rep_vector(0, N), theta_u * L);
{
vector[N] mu;
for (n in 1:N)
mu[n] <- alpha + cov[n] * beta + u[n];
Ad ~ normal(mu, theta_e);
}
}
"
stan_glm <- stan_model(model_code = stan_glm)
5.9 * 6.5
5.9 * 165
5.96 * 165
6 * 30
6 * 15
library(dplyr)
library(KEGGREST)
library(biomaRt)
477 / 1921
options(stringsAsFactors = F)
library(dplyr)
igap_s1 = read.delim("~/GitHub/Adsp/IGAP/IGAP_stage_1.txt")
igap_s1s2 = read.delim("~/GitHub/Adsp/IGAP/IGAP_stage_1_2_combined.txt")
all(igap_s1s2$MarkerName %in% igap_s1$Ma)
head(igap_s1)
igap_s1$MarkerName
head(igap_s1)
save(igap_s1, igap_s1s2, file = "~/GitHub/Adsp/IGAP/IGAP.rdt")
igap_s1$UID = with(igap_s1, paste0(Chromosome, Position))
head(igap_s1)
igap_s1$UID = with(igap_s1, paste(Chromosome, Position, sep = "-"))
head(igap_s1)
igap_s1s2$UID = with(igap_s1s2, paste(Chromosome, Position, sep = "-"))
head(igap_s1s2)
save(igap_s1, igap_s1s2, file = "~/GitHub/Adsp/IGAP/IGAP.rdt")
load("~/Desktop/GWAS/optimizing.rdt")
gwas = do.call(rbind, glm.fit)
gwas = filter(gwas, UID %in% igap_s1$UID)
nrow(gwas)
save(igap_s1, igap_s1s2, gwas, file = "~/GitHub/Adsp/IGAP/IGAP.rdt")
glmm = gwas
rm(gwas)
load("~/Desktop/GWAS/QtlRel.rdt")
lmm = do.call(rbind, lmm.fit)
lmm = filter(lmm, UID %in% igap_s1$UID)
save(igap_s1, igap_s1s2, glmm, lmm, file = "~/GitHub/Adsp/IGAP/IGAP.rdt")
head(glmm)
head(lmm)
head(igap_s1)
all(glmm$UID == igap_s1$UID)
?match
match(glmm$UID, igap_s1$UID)
igap = igap_s1[match(glmm$UID, igap_s1$UID), ]
head(igap)
nrow(glmm) / nrow(igap_s1)
all(igap$UID == glmm$UID)
plot(glmm$LOD, -log10(igap$Pvalue))
cor(glmm$LOD, -log10(igap$Pvalue))
cor(lmm$LOD, glmm$LOD)
plot(lmm$LOD, glmm$LOD)
-log10(igap$Pvalue)
-log10(igap$Pvalue
)
summary(-log10(igap$Pvalue))
x = -log10(igap$Pvalue)
x[x > 100, ]
x[x > 100]
which(x>100)
which(x>200)
x[x > 200]
igap[x > 200, ]
ext = igap[igap$Pvalue == 0, ]
head(igap)
with(glmm, UID %in% ext$UID)
filter(glmm, UID %in% ext$UID)
summary(igap$Pvalue)
cor(glmm$LOD[! glmm$UID %in% ext$UID], -log10(igap$Pvalue[! glmm$UID %in% ext$UID]))
rm(list = ls())
setwd("~/GitHub/byglmm")
load("./igap/igap.rdt")
load("./data/hg19.rdt")
load("./gwas/gwas_c_prior.rdt")
w_prior[[7]] = NULL
w_prior = lapply(w_prior, function(x) x[ !grepl("singular", x[, "p"]), ] )
w_prior = do.call(rbind, w_prior)
head(w_prior)
str(w_prior)
y = as.numeric(w_prior)
head(y)
table(is.na(w_prior[, "se"]))
y = as.data.frame(w_prior)
x = as.numeric(w_prior[, "p"]) / as.numeric(w_prior[, "se"])
x
names(x) = rownames(w_prior)
summary(x)
w_prior = x
N1 <- nrow(w_prior)
vId = names(w_prior)
N1 <- length(w_prior)
load("./gwas/gwas_c_prior.rdt")
w_prior[[7]] = NULL
w_prior = lapply(w_prior, function(x) x[ !grepl("singular", x[, "p"]), ] )
w_prior = do.call(rbind, w_prior)
p = as.numeric(w_prior[, "p"])
se = as.numeric(w_prior[, "se"]
)
p_w_prior <- pnorm(abs(p), sd = se, lower.tail = F) * 2
summary(p_w_prior)
N1 <- nrow(w_prior)
vId <- rownames(w_prior)
summary(-log10(p_w_prior))
table(p_w_prior == 0)
y = data.frame(vId = vId, pvalue = p_w_prior)
str(y)
y$vId = as.character(y$vId)
y = y[! is.na(y$pvalue), ]
y$pvalue[y$pvalue == 0] = 1e-43
chrlen <- read.delim("~/GitHub/X/genomes/human.hg19.genome", header = F)
chrlen <- chrlen[match(paste0("chr", 1:22), chrlen$V1), ]
chrlen <- cumsum(as.numeric(chrlen$V2)) * 1e-6  # Mb
names(chrlen) <- c(1:22)
chrmid <- diff(c(0, chrlen)) * 0.5 + c(0, chrlen[-length(chrlen)])
head(y)
vId = rownames(y)
chr <- as.numeric(gsub("-.*", "", vId))
pos <- as.numeric(gsub(".*-", "", vId)) * 1e-6  # Mb
pos <- c(0, chrlen)[chr] + pos
manhattan <- data.frame(chr = chr, pos = pos, uid = vId, p = -log10(y$pvalue))
png("./gwas/manhattan_p.png", width = 2e3, height = 1e3, res = 200)
ggplot(manhattan, aes(x = pos, y = p)) +
geom_point(alpha = 0.7) + geom_hline(yintercept = 7.3, color = "black") +
scale_x_continuous(breaks = chrmid, labels = names(chrlen), limits = c(0, max(pos))) +
scale_color_manual(values = mycol) + theme_bw() + xlab("") + ylab("-log10(P)") +
theme(legend.key = element_blank())
dev.off()
library(ggplot2)
png("./gwas/manhattan_p.png", width = 2e3, height = 1e3, res = 200)
ggplot(manhattan, aes(x = pos, y = p)) +
geom_point(alpha = 0.7) + geom_hline(yintercept = 7.3, color = "black") +
scale_x_continuous(breaks = chrmid, labels = names(chrlen), limits = c(0, max(pos))) +
scale_color_manual(values = mycol) + theme_bw() + xlab("") + ylab("-log10(P)") +
theme(legend.key = element_blank())
dev.off()
head(y)
head(manhattan)
head(vId)
vId = rownames(y$vId)
chr <- as.numeric(gsub("-.*", "", vId))
pos <- as.numeric(gsub(".*-", "", vId)) * 1e-6  # Mb
pos <- c(0, chrlen)[chr] + pos
manhattan <- data.frame(chr = chr, pos = pos, uid = vId, p = -log10(y$pvalue))
vId = y$vId
chr <- as.numeric(gsub("-.*", "", vId))
pos <- as.numeric(gsub(".*-", "", vId)) * 1e-6  # Mb
pos <- c(0, chrlen)[chr] + pos
manhattan <- data.frame(chr = chr, pos = pos, uid = vId, p = -log10(y$pvalue))
png("./gwas/manhattan_p.png", width = 2e3, height = 1e3, res = 200)
ggplot(manhattan, aes(x = pos, y = p)) +
geom_point(alpha = 0.7) + geom_hline(yintercept = 7.3, color = "black") +
scale_x_continuous(breaks = chrmid, labels = names(chrlen), limits = c(0, max(pos))) +
scale_color_manual(values = mycol) + theme_bw() + xlab("") + ylab("-log10(P)") +
theme(legend.key = element_blank())
dev.off()
summary(y$pvalue)
min(y$pvalue)
manhattan$p[manhattan$p > 43] = 43
png("./gwas/manhattan_p.png", width = 2e3, height = 1e3, res = 200)
ggplot(manhattan, aes(x = pos, y = p)) +
geom_point(alpha = 0.7) + geom_hline(yintercept = 7.3, color = "black") +
scale_x_continuous(breaks = chrmid, labels = names(chrlen), limits = c(0, max(pos))) +
scale_color_manual(values = mycol) + theme_bw() + xlab("") + ylab("-log10(P)") +
theme(legend.key = element_blank())
dev.off()
rm(list = ls())
setwd("~/GitHub/Il21/Crotty2015")
library(xlsx)
tfh = read.xlsx("tfh.xlsx", sheetName = "TFH_2", row.names = 1, stringsAsFactors = F)
options(stringsAsFactors = F)
head(tfh)
nrow(tfh)
summary(tfh$p.value * 1e3 < 0.05)
filter(tfh, p.value < 0.05 / 1e3)
library(dplyr)
filter(tfh, p.value < 0.05 / 1e3)
hist(tfh$PP_avg)
head(tfh)
rownames(tfh)[tfh$p.value < 0.05 / 1e3]
rownames(tfh)[tfh$p.value < 0.05 / 1e2]
file <- "GSE67334_TFH.Vs.TH1.DESeq_Analysis_DE_Genes.txt"
three <- read.table(file, header = T, row.names = 1, sep = "\t")
head(three)
load("../data/profile12.rdt")
names(profile1)
profile1[[1]]
profile2[[1]]
profile2[[2]]
profile1[[2]]
nn = read.xlsx("./Results/new.xlsx", sheetName = "Naive", row.names = 1)
setwd("~/GitHub/Il21")
nn = read.xlsx("./Results/new.xlsx", sheetName = "Naive", row.names = 1)
head(nn)
str(nn)
pp = read.xlsx("./Results/new.xlsx", sheetName = "ACT-Il21", row.names = 1)
pp = read.xlsx("./Results/new.xlsx", sheetName = "ACT-IL21", row.names = 1)
np = read.xlsx("./Results/new.xlsx", sheetName = "ACT", row.names = 1)
head(np)
head(three)
table(three$pvalue < 0.05)
table(three$padj < 0.05)
log2(320 / 219)
three_expr <- three[grep("Rep", names(three))] # read count
head(three_expr)
three_exp <- three[grep("Rep", names(three))] # read count
table(rowMax(three_exp) > 20)
library(Biobase)
table(rowMax(three_exp) > 20)
table(rowMax(as.matrix(three_exp)) > 20)
three <- filter(three, rowMax(as.matrix(three_exp)) > 20)
head(three)
2^0.2
tfh = filter(three, padj < 0.05 & log2FoldChange > 0.2)
th1 = filter(three, padj < 0.05 & log2FoldChange < -0.2)
library(VennDiagram)
install.packages("VennDiagram")
library(VennDiagram)
library(gplots)
?venn
library(gplot)
library(venneuler)
install.packages("venneuler")
library(venneuler)
venn = venneuler(NN = rownames(nn), np = rownames(np))
?venneuler
venn = venneuler(c(NN = rownames(nn), np = rownames(np)))
venneuler(c(NN = rownames(nn), NP = rownames(np)))
